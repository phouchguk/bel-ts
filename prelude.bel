;; bel source
(set no [id _ nil])

(set atom (fn (x)
  (no (id (type x) 'pair))))

(set all (fn (f xs)
  (if (no xs)      t
      (f (car xs)) (all f (cdr xs))
                   nil)))

(set some (fn (f xs)
  (if (no xs)      nil
      (f (car xs)) xs
                   (some f (cdr xs)))))

(set reduce (fn (f xs)
  (if (no (cdr xs))
      (car xs)
      (f (car xs) (reduce f (cdr xs))))))

(set cons (fn args
  (reduce join args)))

(set append (fn args
  (if (no (cdr args)) (car args)
      (no (car args)) (apply append (cdr args))
                      (cons (car (car args))
                            (apply append (cdr (car args))
                                          (cdr args))))))

(set snoc (fn args
  (append (car args) (cdr args))))

(set list (fn args
  (append args nil)))

(set map (fn (f . ls)
  (if (no ls)       nil
      (some no ls)  nil
      (no (cdr ls)) (cons (f (car (car ls)))
                          (map f (cdr (car ls))))
                    (cons (apply f (map car ls))
                          (apply map f (map cdr ls))))))

(set let (macro (parms val . body)
  `((fn (,parms) ,@body) ,val)))

(set def (macro (n . rest)
  `(set ,n (fn ,@rest))))

(set mac (macro (n . rest)
  `(set ,n (macro ,@rest))))

(mac or args
  (if (no args)
      nil
      (let v (uvar)
        `(let ,v ,(car args)
           (if ,v ,v (or ,@(cdr args)))))))

(mac and args
  (reduce (fn es (cons 'if es))
          (or args '(t))))

;; tests

(set double (macro (x) `(+ ,x ,x)))

(double 7)

(no (double 9))

(atom nil)

(atom 'a)

(atom '(a))

(all atom '(a b))

(all atom nil)

(all atom '(a (b c) d))

(some atom '((a b) (c d)))

(some atom '((a b) c (d e)))

(reduce join '(a b c))

(cons 'a '(b c))

(cons 'a 'b 'c '(d e f))

(append '(a b c) '(d e f))

(append '(a) nil '(b c) '(d e f))

(snoc '(a b c) 'd 'e)

(list)

(list 'a)

(list 'a 'b)

(map car '((a b) (c d) (e f)))

(map cons '(a b c) '(1 2 3))

(map cons '(a b c) '(1 2))

(let x 'a
    (cons x 'b))
