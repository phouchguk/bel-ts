;; bel source
(set no (fn (x)
  (id x nil)))

(set atom (fn (x)
  (no (id (type x) 'pair))))

(set all (fn (f xs)
  (if (no xs)      t
      (f (car xs)) (all f (cdr xs))
                   nil)))

(set some (fn (f xs)
  (if (no xs)      nil
      (f (car xs)) xs
                   (some f (cdr xs)))))

(set reduce (fn (f xs)
  (if (no (cdr xs))
      (car xs)
      (f (car xs) (reduce f (cdr xs))))))

(set cons (fn args
  (reduce join args)))

(set append (fn args
  (if (no (cdr args)) (car args)
      (no (car args)) (apply append (cdr args))
                      (cons (car (car args))
                            (apply append (cdr (car args))
                                          (cdr args))))))

(set snoc (fn args
  (append (car args) (cdr args))))

(set list (fn args
  (append args nil)))

(set map (fn (f . ls)
  (if (no ls)       nil
      (some no ls)  nil
      (no (cdr ls)) (cons (f (car (car ls)))
                          (map f (cdr (car ls))))
                    (cons (apply f (map car ls))
                          (apply map f (map cdr ls))))))

;; tests

(set double (macro (x) (join '* (join x (join x nil)))))

(set x 30)

1

2

(display "done;") ; testing ; doesn't mess up string

(iff (coin)
     ((fn (x) x) (+ x 12))
     (ccc (fn (return)
            (iff (coin)
                 (return (- 100 1))
                 3))))

(double 7)

(no (double 9))

(no nil)

(no t)

id

(apply + '(1 2))

(apply + 1 '(2))

(fn (a . b) b) ; checking expand handles improper lists

((fn (a . b) a) 1 2 3)
((fn (a . b) b) 1 2 3)

(apply (fn (a b . c) (join a (join b (join c nil)))) '(1 2 . 3))
